install.packages("slidify")
library("tools", lib.loc="/usr/lib/R/library")
library("KernSmooth", lib.loc="/usr/lib/R/library")
## This is a markdown file
getwd
getwd ()
myfunction <- function() (
x <- rnorm(100)
mean(x)
)
myfunction <- function() (
x<-rnorm(100)
mean(x)
)
myfunction <- function() (
x <- rnorm(100)
mean(x)
)
myfunction <- function() (
x <- rnorm(100)
mean(x)
)
get wd
getwd
getwd ()
getwd ()
dir()
ls
x <- 1:20
x
x
m <- matrix(1:6, nrow = 2, ncol = 3)
m
m <- 1:10
m
dim(m) <- c(2, 5)
m
x <- 1:3
y <- 10:12
cbind(x, y)
rbind (x, y)
m
m <- rbind (x, y)
m
install.packages("swirl")
library(swirl)
q()
install_from_swirl("R Programming")
library(swirl)
swirl()
5+7
x<-5+7
x
y <- x-3
y
z <-c(1.1, 9, 3.14)
?c
z
c(z, 555, z)
z*2+100
my_sqrt <- sqrt(z -1)
my_sqrt
my_div <- z/my_sqrt
my_div
c(1, 2, 3, 4) + c(0, 10)
c(1, 2, 3, 4) + c(0, 10, 100)
z*2+1000
my
my_div
bye()
q()
data read.table(hw_1data.csv)
data <- read.table(hw_1data.csv)
data <- read.table(hw1_data.csv)
data <- read.csv(hw1_data.csv)
data <- read.csv("hw1_data.csv")
ls
cd
initial <- read.csv("hw1_data.csv",nrows = 2)
args(lm)
library(datasets)
data(iris)
?iris
iris
summary(iris)
head(iris)
colMeans(iris)
colMeans(iris$Sepal.Length)
apply(iris ,2 ,mean)
rowMeans(iris[, 1:4])
apply(iris[, 1:4], 2, mean)
v <-apply(iris[, 1:4], 2, mean)
v
apply(iris[, 1:4], 1, mean)
colMeans(iris)
colMeans("iris")
colMeans(iris[,1:5])
colMeans(iris[,1:4])
s <- split(iris, iris$Species)
s
lapply(s, function(iris) colMeans(iris[,1]))
lapply(s, colMeans(iris[,1]))
lapply(s, mean(iris[,1]))
lapply(s, mean(iris$Sepal.Length)
lapply(s, mean(iris$Sepal.Length)
lapply(s, mean(iris$Sepal.Length))
lapply(s, function(iris) colMeans(iris[,1:4]))
lapply(s, function(iris$virginica) colMeans(iris[,1:4]))
lapply(s$virginica, function(iris) colMeans(iris[,1:4]))
lapply(s, function(iris$virginica) colMeans(iris[,1:4]))
lapply(s$virginica, colMeans(s[,1:4]))
lapply(s$virginica, function(s) colMeans(s[,1:4]))
lapply(s$virginica, function(s) colMeans(s[,1:4]))
lapply(s, function(x) colMeans(x[,1:4]))
lapply(s$virginica, function(x) colMeans(x[,1:4]))
lapply(s$virginica, function(x) colMeans(x[,1]))
lapply(s$virginica, mean(iris$Sepal.Length))
lapply(s, function(x) colMeans(x[,1:4]))
library(datasets)
data(mtcars)
?mtcars
str(mtcars)
summary(mtcars)
head(mtcars)
tapply(mtcars$cyl, mtcars$mpg, mean)
str(tapply)
tapply(mtcars$cyl, mtcars$mpg, mean, simplify = TRUE)
tapply(mtcars$mpg, mtcars$cyl, mean)
str(split)
s1 <- split(mtcars, mtcars$cyl)
s1
hpmeans4 <- lapply(s1, apply(s1&4, s1$`4`, mean))
s1$`4`
mean(s1$`4`[["hp"]])
avgh4 <- mean(s1$`4`[["hp"]])
avghp4 <- mean(s1$`4`[["hp"]])
avghp4
avghp8 <- mean(s1$`8`[["hp"]])
abs(avghp4 - avghp8)
avghp8
209.2143 - 82.63636
debug(ls)
ls
-q
exit
-q()
?browser
q()
exit
debug
setwd("~/datasciencecoursera/Assignments")
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
> B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
B = matrix(c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
B
makeCacheMatrix(B)
cacheSolve(B)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get, setsolve = setsolve,getsolve = getsolve)
}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get, setsolve = setsolve,getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
B = matrix(c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
B
makeCacheMatrix(B)
s
solve(B)
> B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=3)
B = matrix(c(2, 4, 3, 1, 5, 7), nrow=3, ncol=3)
B
solve(B)
c=rbind(c(1, -1/4), c(-1/4, 1))
c
solve(c)
makeCacheMatrix(c)
cacheSolve(c)
cacheSolve(s)
s
m <- makeCacheMatrix(c)
m
cacheSolve(m)
m <- matrix(c(-1, -2, 1, 1), 2,2)
x <- makeCacheMatrix(m)
x
x$get(x)
x$get()
inv <- cacheSolve(x)
inv
inv <- cacheSolve(x)
inv
m %*% m
inv %*% inv
m %*% inv
matrix(runif(100,-1,1), nrow=10, ncol=10)
m <- matrix(runif(100,-1,1), nrow=10, ncol=10)
makeCacheMatrix(m)
m
inv <- cacheSolve(m)
inv <- makeCacheMatrix(m)
m %*% inv
m
inv
cacheSolve(inv)
inv2 <- cacheSolve(inv)
m %*% inv2
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
a <- makeVector(c(5,1,3))
a
cachemean(a)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get, setsolve = setsolve,getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
m <- matrix(runif(100,-1,1), nrow=10, ncol=10)
inv <- makeCacheMatrix(m)
inv
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get, setsolve = setsolve,getsolve = getsolve)
s
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
m <- matrix(runif(100,-1,1), nrow=10, ncol=10)
inv <- makeCacheMatrix(m)
inv
inv
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<-y
s <<- NULL
}
get <- function ()x
setsolve <-function(solve) s <<- solve
getsolve <- function () s
list(set = set, get = get, setsolve = setsolve,getsolve = getsolve)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
m <- matrix(runif(100,-1,1), nrow=10, ncol=10)
inv <- makeCacheMatrix(m)
inv$get()
cacheSolve(inv)
makeCacheMatrix(inv)
inv <-makeCacheMatrix(inv)
cacheSolve(inv)
inv2 <-makeCacheMatrix(inv)
cacheSolve(inv2)
m
inv <- makeCacheMatrix(m)
inv
inv$get()
cacheSolve(inv)
m <- matrix(c(-1, -2, 1, 1), 2,2)
m
x <- makeCacheMatrix(m)
x$get
x$get()
x$getsolve()
x$getsolve(m)
x$getsolve(x)
x$getsolve() s
x$getsolve()
s
s <- x$getsolve()
s
c <- x$getsolve(m)
m
solve(m)
## With the following functions, the inverse of a matrix can be calculated.
## The first function calculates creates a special object matrix which stores
## 4 functions and can cache its inverse.
## The second function, first check wether the inverse of matrix can already be
## found in the cache and, if not, calculates then
## the inverse of that matrix.
## The following function actually stores 4 functions inside it: set, get,
##setsolve and getsolve;
makeCacheMatrix <- function(x = matrix()) {
## s will be the value of the matrix inverse, and it's firs assigned
## to be NULL
s <- NULL
## the value of the main function is changed from x to y; at the same
## time the inverse of the previous matrix is set to NULL (the previous
## inverse is not necessary anymore).
set <- function(y) {
x <<-y
s <<- NULL
}
## the function "get" returns the matrix stored in the main function.
get <- function ()x
## the following function store the value of the inverse of the matrix
## indicated in the main function.
setsolve <-function(solve) s <<- solve
## returns the value of the inverse of the matrix stored in the main
## function.
getsolve <- function () s
## with the "list" function the 4 functions are stored in the
## "makeCacheMatrix" function.
list(set = set, get = get, setsolve = setsolve, getsolve = getsolve)
}
## The following function will return the inverse of a given matrix. If the
## inverse of the matrix is already stored in chache, the function will no
## continue and will return the stored value instead and a message
## "getting cached data".
cacheSolve <- function(x, ...) {
s <- x$getsolve()
## the function checks if the value is stored in cache and it's not NULL
if(!is.null(s)) {
## if the inverse value already exist, the function will show
## the message "getting cached data" and will return the stored
## vale.
message("getting cached data")
return(s)
}
## if the inverse of the matrix was not already stored in cache, is then
## calculated, retrieved and stored in cache.
data <- x$get()
s <- solve(data, ...)
x$setsolve(s)
s
}
m <- matrix(runif(100,-1,1), nrow=10, ncol=10)
d <- makeCacheMatrix(m)
cacheSolve(m)
cacheSolve(d)
inv <- cacheSolve(d)
inv
-q()
